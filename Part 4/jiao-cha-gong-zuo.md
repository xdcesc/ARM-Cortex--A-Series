## 交叉工作

当核心执行 ARM 指令时，它被称为在 ARM 状态下操作，反之当它在 Thumb 状态下操作时，它正在执行 Thumb 指令。一个处于特定状态的核只能从那个指令集中执行指令。我们必须确保核不接收错误指令集的指令。

每个指令集都有改变处理器状态的指令。如果代码符合 ARM 和 Thumb 过程调用标准的要求\(见第十五章\)，ARM 和 Thumb 代码是可以混合使用的。编译器生成的代码经常会这样做，但是汇编语言程序员必须小心注意遵守指定的规则

处理器状态的选择由 `CPSR` 中的 T 位控制。参见第三章的 Figure 3-6。当 T = 1 时，处理器处于 Thumb 状态。当 T =0 时，处理器处于 ARM 状态。然而，当修改 T 位时，还需要刷新指令管道（以避免在一种状态下解码指令，然后在另一种状态下执行）。为了做到这一点，我们使用了特殊的指令。可以是 `BX` \(Branch with eXchange\) 和 `BLX` \(Branch and Link witth eXchange\)。同样 `PC`  的 `LDR` 和 `PC` 的 `POP/LDM` 也有这种行为。除了使用这些指令更改处理器状态外，程序集程序员还必须使用适当的指令来告诉汇编器为适当的状态生成适当的代码。

`BX` 或 `BLX` 指令分支到指定寄存器中包含的地址，或操作码中指定的偏移量。分支目标地址的 \[0\] 比特值决定执行是在 ARM 状态还是Thumb 状态继续。ARM \(对齐到字边界\)和 Thumb \(对齐到半字边界\)指令都不使用 \[0\] 比特来形成指令地址。因此这一位可以被安全地用于提供额外的信息，这个信息用于决定是否 `BX` 或 `BLX` 指令应该改变状态为 ARM \(地址位 \[0\]= 0\) 或 Thumb \(地址\[0\]= 1\)。如果调用者的指令集与标签的指令集不同时，`BL label` 在链接适当时将会变成一个 `BLX label`（假设它是无条件的）。

这些指令的典型用法是使用 `BL` 或 `BLX` 指令从一个函数调用另一个函数，然后使用 `BX LR` 指令返回该函数。或者，我们可以有一个 non-leaf 函数，在进入时将链接寄存器推送到堆栈中，在退出时将存储的链接寄存器从堆栈中弹出到程序计数器中。这里，我们没有使用 `BX LR` 指令返回，而是有一个内存负载。修改 PC 的内存加载指令还可能根据加载地址的 \[0\] 比特的值改变处理器状态。



