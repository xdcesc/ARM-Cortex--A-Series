## 数据处理操作

数据处理操作本质上是核心的基本算术和逻辑运算。乘法运算可以看作是这些运算的一个特例。它们通常具有略微不同的格式和规则，并在核心的专用单元中执行。

ARM 内核只能在寄存器上执行数据处理，而不能直接在内存上执行。数据处理指令\(大部分\)使用一个目标寄存器和两个源操作数。基本格式可以认为是操作码，可选地后跟条件码，可选地后跟S \(set flags\)，如下所示:

`Operation{cond}{S} Rd, Rn, Operand2`

Table 5-3 总结了数据处理汇编语言指令，给出了它们的助记码、操作数和它们的功能的简要描述。附录 A 给出所有可用指令的更完整描述。![](/assets/table5-3.png)

对于大多数程序员来说，这些指令的目的和功能都是显而易见的，但是有些需要额外的解释。

在算术运算中，请注意，move 操作 MOV 和 MVN 只需要一个操作数\(我们将看到，为了最大限度地提高灵活性，这被视为一个第二操作数\)。RSB 做一个反向减法——也就是说它从第二个操作数中减去第一个操作数。这个指令是必需的，因为第一个操作数是不灵活的——它只能是一个寄存器值。要写 R0 = 100 - R1，你必须使用 RSB R0 R1 \#100，因为下标 R0 \#100 R1 是非法指令。操作 ADC 和 SBC 执行带进位的加减运算。这允许您对大于32位的值进行算术运算。

逻辑操作本质上与相应的 C 运算符相同。注意 ORR 而不是 OR 的用法。这是因为最初的 ARM 指令集对于所有数据处理操作都有三个字母缩写。BIC 指令执行一个与第二操作数相反的寄存器的 AND。例如，如果想清除寄存器 R0 的比特 \[11\]，可以使用指令 `BIC R0， R0， #0x800` 来完成。

第二个操作数 0x800 只将 \[11\] 位设置为1，其他所有位都为 0。BIC 指令将这个操作数反转，将除比特 \[11\] 之外的所有位都设置为逻辑位。将这个值与 R0 中的值结合在一起，会有清除位 \[11\] 的效果，然后将这个结果写回 R0。

比较和测试指令修改了CPSR\(没有其他效果\)。

### 第二操作数和桶式移位器

所有数据处理操作的第一个操作数必须始终是寄存器。第二个操作数灵活得多，可以是立即值\(\#x\)、寄存器\(Rm\)或按立即值移位的寄存器或寄存器“Rm, shift \#x”或“Rm, shift Rs”。有五种移位操作:左移\(LSL\)、逻辑右移\(LSR\)、算术右移\(ASR\)、\(旋转\)循环右移\(ROR\)和扩展\(旋转\)循环右移\(RRX\)（循环右移过程中将左边的高位用 CPSR 的 C 标志位填充）。

右移会在寄存器顶部创建空位置。在这种情况下，您必须区分逻辑移位\(将0插入到最重要的位中\)和算术移位\(用符号位填充空白位\)寄存器的位\[31\]。因此，ASR 操作可以在有符号值上使用，LSR 在无符号值上使用。左移不需要这样的区别，总是在最不重要的位置插入 0。

因此，与许多汇编语言不同，ARM 汇编语言不需要显式的移位指令。相反，MOV 指令可用于移位和旋转。R0 = R1 &gt;&gt; 2 用 `MOV R0 R1 LSR #2` 表示。同样，将移位与 ADD、SUB 或其他指令组合在一起也很常见。例如，要用 R0 乘以5，你可以这样写:

`ADD R0, R0, R0, LSL #2`

左移 n 的地方实际上是一个乘以 2 的 n 次方,这有效地使 R0 = R0 + \(4×R0\)。右移提供了相应的除法运算，尽管 ASR 的除法方法与 C 中的除法方法不同。

除了乘法和除法，移位操作数的另一个常见用法是数组索引查找。考虑这样的情况：R1指向 int\(32位\) 值数组的基元素地址，R2 是指向数组中第 n 个元素的索引。可以获得数组值与单个负荷指令使用计算 R1 + \(R2×4\) 得到适当的解决。Example 5-3 提供了 ARM 指令中使用的不同第二操作数类型的示例。![](/assets/example5-3.png)

### 乘法操作

乘法运算很容易理解。需要注意的一个关键限制是，没有可以乘以一个直接值的操作。多重操作只对寄存器中的值操作。乘以一个常数可能需要先把这个常数装入寄存器。ARM 处理器的后期版本添加了大量的指令，为 8 位、16 位和 32 位数据提供了一系列的可能性。在查看 DSP 指令时，我们将在整数 SIMD 指令中考虑这些。

Table 5-4 总结了乘法的汇编语言指令，给出它们的助记码、操作数和它们的函数的简要描述。![](/assets/table5-4.png)

### 额外乘法

乘法操作提供了将一个 32 位寄存器与另一个寄存器相乘的方法，以生成 32 位结果或 64 位有符号或无符号结果。在所有情况下，都可以将 32 位或 64 位的值累加到结果中。额外乘法指令被添加。有符号最重要的 word 乘法，SMMUL, SMMLA 和 SMMLS。这些执行 32×32 位相乘的结果是保留最高32位，32位底部丢弃。结果可以通过应用 R 后缀来四舍五入，否则会被截断。UMAAL\(Unsigned Multiply Accumulate Accumulate Long\)指令执行 32×32 位乘法和添加两个 32 位寄存器的内容。

### 整数 SIMD 指令

Single Instruction, Multiple Data \(SIMD\) 指令在 ARMv6 架构中第一次添加并且提供能够在 32 位寄存器中打包、提取和解包 8 位和 16 位的数量，并通过一条指令对这些打包的数据执行多种算术运算，如加、减、比较或相乘。这些不能被更强大的高级 SIMD\(NEON\)操作所搞混，NEON 在 v7 架构中引入并会在第七章和 ARM® NEON™ Programmer’s Guide 中详细介绍。

**整数寄存器 SIMD 指令**

ARMv6 SIMD 操作使用了 CPSR 中的 GE\(大于或等于\) 标志，这些与正常条件标志不同。一个 word 中有一个对应于四个字节位置的标志。正常的数据处理操作产生一个结果，并设置 N、Z、C 和 V 标志\(如 Figure 3-8 所示\)。SIMD 操作最多产生 4 个输出，并且只设置 GE 标志，以指示溢出。MSR 和 MRS 指令可用于直接写入或读取这些标志。

















