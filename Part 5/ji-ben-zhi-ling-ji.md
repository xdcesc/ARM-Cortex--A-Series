## 指令集基础

指令集的所有部分都有一些共同的特性。

### 常数和立即值

ARM 或 Thumb 汇编语言指令的长度只有 16 位或 32 位。这带来了一些问题。这意味着你不能在操作码中编码任意的32位值。

在 ARM 指令集中，由于操作码位用于指定条件码、指令本身和要使用的寄存器，因此只有 12 位可用来指定立即值。你必须在如何使用这 12 位元上有点创造性。不是指定大小为 -2048 到 +2047 的常量，而是将 12 位划分为 8 位常量和 4 位旋转值。旋转值使 8 位常量值以 2 步的方式从 0 到 30 的多个位置向右旋转，即 0、2、4、6、8……

因此，你可以有像 `0x23` 或 `0xFF` 的立即值。你也可以生成其他有用的立即值，例如外设地址或内存块。例如，可以通过将 `0x23000000` 表示为 `0x23 ROR 8` `来生成 0x23000000` \(参见附录 A 的 `ROR` \)。但是许多其他常量，比如 `0x3FF`，不能在一条指令中生成。对于这些值，你必须在多个指令中构造它们，或者从内存中加载它们。程序员通常不关心这个问题，除非汇编器报错并报出无效常数的错误。相反，您可以使用汇编语言伪指令来执行生成所需常量所需的任何操作。

在一条指令中编码的常数值在 Thumb 中可以是下面的一个：

* a constant that can be produced by rotating an 8-bit value by any even number of bits
   within a 32-bit word
* a constant of the form `0x00XY00XY`
* a constant of the form `0xXY00XY00`
* a constant of the form `0xXYXYXYXY`

其中 `XY` 是一个在 `0x00` 到 `0xFF` 的十六进制数。

`MOVW` 指令\(move wide\)，会将一个 16-bit 常数移至一个寄存器，并在目标寄存器的头 16 位置 0。`MOVT` 指令\(move top\)会将一个 16-bit 常数移至一个给定寄存器的前半部分，且不改变后 16 位。这允许一个 `MOV32` 伪指令构建任何一个 32-bit 的常数。汇编器能提供在这里更多的帮助，前缀 `:upper16:` 和 `:lower16:` 允许你提取一个 32 位常数对应半份：

`MOVW R0, #:lower16:label`

`MOVT R0, #:upper16:label`

尽管这需要两条指令，但并不需要额外的空间来存储这个常数，并且也没有必要从内存中读取这一数据项。

你也可以使用伪指令 `LDR Rn, =<constant>` 或 `LDR Rn, =label`。这是对于那些没有 `MOVW` 和 `MOVT` 指令的老处理器可用的唯一办法。汇编器会使用最好的序列来在制定寄存器中生成这个常数（`MOV`、`MVN` 中的一个或者文字池中的一个 `LDR`）。文字池是保存在代码部分中的常量数据区域，通常在函数结束后和另一个函数开始之前。如果需要手动控制文字池的位置，可以使用汇编器指令 armasm 的 `LTORG`，或使用 GNU 工具时的 `.ltorg`。加载的寄存器可能是程序计数器，这就会导致分支程序。

### 条件执行

ARM 指令集的一个特征就是几乎所有指令都可以条件化。在大多数其他架构，只有分支和跳跃能够被条件化执行。这对于避免 if/then/else 构造中的条件分支或用于复合比较非常有用。

作为例子，我们考虑一个用于寻找两个值 R0 和 R1 中的小的那个并将结果存入 R2 的代码，见 Example 5-1。后缀 LT 表明，只有在最近的设置标志的指令返回小于的时候指令才能执行，GE 则表示大于或等于\(greater than or equal\)。![](/assets/example5-1.png)现在我们来看使用条件化的 `MOV` 指令，而不是使用分支时编写的代码，见 Example 5-2。![](/assets/example5-2.png)后者的代码块不仅更少，而写在更老的 ARM 处理器总会更快的被执行。然而，这种代码实际上在像 Cortex-A9 这样的处理器上运行会更慢，因为在这些处理器中指令间的依赖可能导致比分支更长的延迟，而分支预测可以减少，甚至可能消除分支的成本。

提醒一下，这种编程风格依赖于这样一个事实，即在某些指令上可以随意设置状态标志。如果 Example 5-2 中的 `MOVGE` 指令自动设置了标志，程序可能无法正常工作。加载和存储指令从不设置标志。然而，对于数据处理操作，您可以做选择。默认情况下，在这些指令中会保留标记。如果指令的后缀是 S \(例如，MOVS 而不是 MOV\)，则指令将设置标志。对于显式的比较指令，不需要或不允许使用S后缀。通过使用专用的 PSR 操作指令\(MSR\)，还可以手动设置标志。一些指令基于来自ALU的 carry 设置 carry 标志\(C\)，另一种基于转筒移位器的carry\(在一个时钟周期内按指定的比特数移动一个数据字\)

Thumb-2 技术还引入了 If-Then \(`IT`\) 指令，为最多 4 条连续指令提供条件执行。条件可能是固定的，也可能是其他条件的逆条件。IT 块中的指令还必须指定要应用的条件代码。

IT 是一个 16 位指令，能让几乎所有 Thumb 指令（使用条件代码后缀）根据 ALU 标志的值条件执行（见附录 A）。这个指令的语法为 `IT{x{y{z}}}` ，其中 `x, y, z` 特指 IT 块中对于可选指令的条件转换，可以是 Then（T）或者 Else（E）。例如，ITTET。

`ITT EQ`

`SUBEQ r1, r1, #1`

`ADDEQ r0, r0, #60`

通常，IT 指令是由汇编器自动生成的，而不是手工编码的。通常更改条件代码标志的 16 位指令不会在 IT 块中更改 flags，只有 CMP、CMN 和 TST 的操作是设置标志。在 IT 块中可以使用的指令有一些限制。异常可以在 IT 块中发生，当前 If-then 状态存储在 CPSR 中，因此在异常条目上复制到 SPSR，以便当异常返回时，IT块的执行恢复正常。

某些指令只是设置标志，没有其他效果。这些是 CMP、CMN、TST 和 TEQ，它们类似于 SUBS、ADDS、ANDS 和 EORS，但 ALU 计算的结果仅用于更新标志，而不放在寄存器中。

Table 5-1 列出了几乎可以附在所有指令的15 种条件码。![](/assets/table5-1.png)![](/assets/table5-1%28continued%29.png)

### 状态标志和条件代码

第三章提到的程序状态寄存器存在一个 CPSR 有四个状态标志  \(Z\)ero, \(N\)egative, \(C\)arry 和 o\(V\)erflow。Table 5-2 表明了这些标志位设定操作值的意义。![](/assets/table5-2.png)当一个无符号操作的结果在一个 32 位寄存器中溢出，C 标志将会被设置。例如，这个位可以用来实现用 32 位操作进行 64 位或者更长的运算。

V 标志的操作方式与 C 标志相同，但用于有符号操作。`0x7FFFFFFF` 是可以用 32 位表示的最大带符号正整数。例如，如果向这个值添加 2，结果是 0x80000001，这是一个大的负数。将 V 位设置为表示从\[30\]位看出的向上溢出或从\[31\]位看出的向下溢出。

