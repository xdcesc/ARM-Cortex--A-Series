## 内存指令

ARM 内核只在寄存器上执行算术逻辑单元\(ALU\)操作。唯一受支持的内存操作是 load \(将数据从内存读取到寄存器\)或 store \(将数据从寄存器写入内存\)。与其他指令一样，`LDR` 和 `STR` 可以有条件地执行。

可以通过将 B \(Byte\)、H \(halfword\) 或 D \(doubleword\(64位\)\) 附加到指令后面 \(例如 `LDRB`\) 来指定加载或存储传输的大小。仅对于 load，可以使用额外的 S 来表示有符号字节或半字 \(SB 表示 Signed Byte 或 SH 表示 Signed Halfword\)。请参阅附录 A 的 `LDR` 示例。这种方法很有用，因为如果将 8 位或 16 位的数量加载到 32 位寄存器中，则必须决定如何处理寄存器中最重要的位。无符号数都是zero-extended \(即最重要的 16 或 24 位的寄存器设置为零\)，但对于一个有符号数，需要复制符号位（\[7\] 对于字节，\[15\] 对于半字）到寄存器的前 16\(24\) 位。

### 寻址模式

这里有多种能用于加载和存储的的寻址模式。括号中的数字对应 Example 5-4：

* 寄存器寻址——地址就在寄存器中 （1）
* 预先索引寻址——在进行寻址之前对于基寄存器有一个偏移被加上。这个的基础形式就是 `LDR Rd, [Rn,Op2]` 。偏移量可以是正的或者是负的并且可以是一个立即值，或者是其他有一个可选移位应用的寄存器。（2）（3）
* 带回写预先索引——这是用在指令之后添加的感叹号\(!\)表示的。在发生内存访问之后，通过添加偏移值更新基本寄存器。（4）
* 带回写后索引——这里，偏移值写在方括号后面。来自基寄存器的地址仅用于内存访问，并且在内存访问之后将偏移值添加到基寄存器中。![](/assets/example5-4.png)

### 多路传输

加载和存储多个指令使连续的单词能够从存储器中读取或写入。这些对于堆栈操作和内存复制非常有用。只有 word 可以这样操作，并且必须使用字对齐地址。

操作数是一个基本寄存器\(可选 ! 表示基寄存器的回写\)和大括号之间的寄存器列表。寄存器列表用逗号分隔，用连字符表示范围。加载或存储寄存器的顺序与列表中指定的顺序无关。相反，操作以一种固定的方式进行，最低编号的寄存器总是映射到最低的地址。

例如：

`LDMIA R10!, { R0-R3, R12 }`

这个指令读取由寄存器 \(R10\) 指向的 5 个寄存器的地址，同时因为指定回写，最后 R10 增加 20\(5×4 字节\)。

指令还必须明确如何从基寄存器 Rd 开始。四种可能是: IA/IB \(Increment After/Before\) 和 DA/DB \(Decrement After/Before\)。还可以使用别名 \(FD、FA、ED 和 EA\) 来指定它们，这些别名可以从堆栈的角度工作，并指定堆栈指针指向堆栈的满顶或空顶，以及堆栈在内存中的上升或下降。

按照惯例，只有 Full Descending \(FD\) 选项用于基于 ARM 处理器的系统中的堆栈。这意味着堆栈指针是指向堆栈内存中最后填充的位置，并将随着每个新数据项推送到堆栈中而递减。

例如：

`STMFD sp!, {r0-r5} ; Push onto a Full Descending Stack`

`LDMFD sp!, {r0-r5} ; Pop from a Full Descending Stack`

Figure 5-5 显示两个寄存器对堆栈的入栈。在执行 `STMFD (PUSH)` 指令之前，堆栈指针指向堆栈的最后一个被占用的单词。指令完成后，栈指针被减为 8\( 2 个 word\)，两个寄存器的内容被写入内存，最低的寄存器被写入到最低的内存地址。![](/assets/figure5-5.png)



