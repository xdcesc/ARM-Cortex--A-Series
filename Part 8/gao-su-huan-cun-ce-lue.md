## 高速缓存策略

在缓存操作中有许多不同的选择。考虑是什么原因将外部内存中的一行放到缓存中(分配策略)，以及控制器如何决定在一组关联缓存中使用哪一行来处理传入数据(替换策略)。当内核执行在缓存(写策略)中命中的写入操作时，也必须控制。

### 分配策略 Allocation policy

当核心执行缓存查找时，它想要的地址不在缓存中，它必须确定是否执行缓存填充并从内存中复制该地址。

* read allocate 策略仅在读上分配缓存线。如果写操作是由在缓存中丢失的核心执行的，那么缓存不会受到影响，写操作将进入层次结构的下一层
* write allocate 策略为缓存中遗漏的读或写分配缓存线(因此更准确地说，可能称为读写缓存分配策略)。对于在缓存中读取丢失的内存和在缓存中写入丢失的内存，执行缓存线填充。这通常与针对当前 ARM 内核的 write-back 策略一起使用，我们将在本节后边可以看到。

### 替代策略 Replacement policy

 当缓存丢失时，缓存控制器必须为传入数据选择集合中的一条缓存线。所选的高速缓存线路称为 victim。如果受害者包含有效的脏数据，那么在新数据写入受害者缓存行之前，必须将该行的内容写入主内存。这叫做 eviction。

 替代策略控制着受害者的选择过程。地址的索引位用于选择一组缓存线，替换策略从要替换的集合中选择特定的缓存线。

 * Round-robin 或 cyclic 替换意味着你有一个计数器(受害者计数器)，它循环通过可用的方法，当它达到最大的方法数量时，循环回到 0；
 * Pseudo-random 替换随机选择要替换的集合中的下一个缓存行。受害者计数器以伪随机方式递增，可以指向集合中的任何一行。
 * Least Recently Used (LRU)替换用于替换最近最少使用的缓存线或页面。

大多数 ARM 处理器同时支持循环策略和伪随机策略。Cortex-A15 处理器也支持 LRU。

循环替换策略通常更容易预测，但是在某些用例中可能会有较差的性能，因此，伪随机策略通常是首选策略。

### Write policy
当核心执行存储指令时，将执行对要写入的地址的缓存查找。对于写入操作的缓存命中，有两个选择。
* Write-through. 使用此策略，对缓存和主内存执行写操作。这意味着缓存和主内存保持一致。因为对主内存有更多的写操作，所以对某些用例来说，通过写策略比回写策略要慢，在这些用例中，相同的内存区域经常被更新。如果正在写入大量连续的内存块，并且可以对写入进行 buffered，那么通过写入与会写写入同样高效。如果预期内存不会很快被读取(比如大内存副本或内存初始化)，那么最好不要用这样的写入来填充缓存。
* Write-back. 在这种情况下，写操作只对缓存执行，而不对主内存执行。他的意思是缓存线和主存储器可以包含不同的数据。高速缓存线路保存较新的数据，主存储器包含较旧的数据(据说是陈旧的)。为了标记这些行，缓存的每一行都有一个相关的脏位(或比特)。当发生写操作更新缓存(而不是主存)时，脏位就被设置好了。如果稍后缓存清除了设置了脏位的缓存行(脏行)，它就把这行写到主存。使用回写缓存策略可以显著降低通信量，降低外部内存速度，从而提高性能并节省电能。但是，如果系统中有其他代理可以同时访问内存，那么必须考虑一致性问题。这些在在第十八章中会详细讲解。
